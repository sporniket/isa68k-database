Row ID	Mnemonic	Synopsys	Opcode	Supplemental Word #1	Supplemental Word #2	Domain	.b	.w	.l	Number of operands	Operand 1	Data Register Direct Mode	Address Register Direct Mode	Address Register Indirect Mode	Address Register Indirect with Postincrement Mode	Address Register Indirect with Predecrement Mode	Address Register Indirect with Displacement Mode	Address Register Indirect with Index (8-Bit Displacement) Mode	Address Register Indirect with Index (Base Displacement) Mode	Memory Indirect Postindexed Mode	Memory Indirect Preindexed Mode	Program Counter Indirect with Displacement Mode	Program Counter Indirect with Index (8-Bit Displacement) Mode	Program Counter Indirect with Index (Base Displacement) Mode	Program Counter Memory Indirect Postindexed Mode	Program Counter Memory Indirect Preindexed Mode	Absolute Short Addressing Mode	Absolute Long Addressing Mode	Immediate Data	Signed value	Operand 2	Data Register Direct Mode	Address Register Direct Mode	Address Register Indirect Mode	Address Register Indirect with Postincrement Mode	Address Register Indirect with Predecrement Mode	Address Register Indirect with Displacement Mode	Address Register Indirect with Index (8-Bit Displacement) Mode	Address Register Indirect with Index (Base Displacement) Mode	Memory Indirect Postindexed Mode	Memory Indirect Preindexed Mode	Program Counter Indirect with Displacement Mode	Program Counter Indirect with Index (8-Bit Displacement) Mode	Program Counter Indirect with Index (Base Displacement) Mode	Program Counter Memory Indirect Postindexed Mode	Program Counter Memory Indirect Preindexed Mode	Absolute Short Addressing Mode	Absolute Long Addressing Mode	Immediate Data	Signed value	Operand 3	Data Register Direct Mode	Address Register Direct Mode	Address Register Indirect Mode	Address Register Indirect with Postincrement Mode	Address Register Indirect with Predecrement Mode	Address Register Indirect with Displacement Mode	Address Register Indirect with Index (8-Bit Displacement) Mode	Address Register Indirect with Index (Base Displacement) Mode	Memory Indirect Postindexed Mode	Memory Indirect Preindexed Mode	Program Counter Indirect with Displacement Mode	Program Counter Indirect with Index (8-Bit Displacement) Mode	Program Counter Indirect with Index (Base Displacement) Mode	Program Counter Memory Indirect Postindexed Mode	Program Counter Memory Indirect Preindexed Mode	Absolute Short Addressing Mode	Absolute Long Addressing Mode	Immediate Data	Brief description	020+ only	020 only	Exclude 68000	Exclude 040
1	ABCD	ABCD Dy,Dx	1100.xxx.100.000.yyy				x			2	x	x																				x																																						Source10 + Destination10 + X → Destination10				
2	ABCD	ABCD -(Ay),-(Ax)	1100.xxx.100.001.yyy				x			2	x					x																				x																																		Source10 + Destination10 + X → Destination10				
3	ADD	ADD <ea>,Dn	1101.nnn.0ss.eee.aaa				x	x	x	2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						Source + Destination → Destination				
4	ADD	ADD Dn,<ea>	1101.nnn.1ss.eee.aaa				x	x	x	2		x																			x			x	x	x	x	x	x	x	x						x	x																						Source + Destination → Destination				
5	ADDA	ADDA <ea>,An	1101.nnn.011.eee.aaa					x		2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x				x																																					Source + Destination → Destination				
6	ADDA	ADDA <ea>,An	1101.nnn.111.eee.aaa						x	2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x				x																																					Source + Destination → Destination				
7	ADDI	ADDI #<data>,<ea>	0000.011.0ss.eee.aaa				x	x	x	2																			x		x	x		x	x	x	x	x	x	x	x						x	x																						Immediate Data + Destination → Destination				
8	ADDQ	ADDQ #<data3.8>,<ea>	0101.ddd.0ss.eee.aaa				x	x	x	2																			3.8		x	x	x	x	x	x	x	x	x	x	x						x	x																						Immediate Data + Destination → Destination				
9	ADDX	ADDX Dy,Dx	1101.xxx.1ss.000.yyy				x	x	x	2	x	x																				x																																						Source + Destination + X → Destination				
10	ADDX	ADDX -(Ay),-(Ax)	1101.xxx.1ss.001.yyy				x	x	x	2	x					x																				x																																		Source + Destination + X → Destination				
11	AND	AND <ea>,Dn	1100.nnn.0ss.eee.aaa				x	x	x	2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						Source Λ Destination → Destination				
12	AND	AND Dn,<ea>	1100.nnn.1ss.eee.aaa				x	x	x	2		x																			x			x	x	x	x	x	x	x	x						x	x																						Source Λ Destination → Destination				
13	ANDI	ANDI #<data>,<ea>	0000.001.0ss.eee.aaa				x	x	x	2																			x		x	x		x	x	x	x	x	x	x	x						x	x																						Immediate Data Λ Destination → Destination				
14	ANDI	ANDI #<data>,CCR	0000.001.000.111.100				x			2	x																		x																																									Source Λ CCR → CCR				
15	ASL	ASL Dx,Dy	1110.xxx.1ss.100.yyy				x	x	x	2		x																			x	x																																						Destination Left Shifted By Count → Destination				
16	ASL	ASL #<data3.8>,Dy	1110.ddd.1ss.000.yyy				x	x	x	2																			x		x	x																																						Destination Left Shifted By Count → Destination				
17	ASL	ASL <ea>	1110.000.111.eee.aaa					x		1	x			x	x	x	x	x	x	x	x						x	x																																										Destination WORD Left Shifted By 1 → Destination				
18	ASR	ASR Dx,Dy	1110.xxx.0ss.100.yyy				x	x	x	2		x																			x	x																																						Destination Right Shifted with sign By Count → Destination				
19	ASR	ASR #<data3.8>,Dy	1110.ddd.0ss.000.yyy				x	x	x	2																			x		x	x																																						Destination Right Shifted with sign By Count → Destination				
20	ASR	ASR <ea>	1110.000.011.eee.aaa					x		1	x			x	x	x	x	x	x	x	x						x	x																																										Destination WORD Right Shifted with sign By 1 → Destination				
21	Bcc	Bcc #<data8>	0110.cccc.dddddddd							1																			8!{0,$ff}																																									If Condition True Then PC + dn → PC				
22	Bcc	Bcc #<data16>	0110.cccc.00000000							1																			16																																									If Condition True Then PC + dn → PC				
23	Bcc	Bcc #<data32>	0110.cccc.11111111							1																			32																																									If Condition True Then PC + dn → PC	x			
24	BCHG	BCHG Dn,Dx	0000.nnn.101.000.xxx						x	2		x																			x	x																																						TEST ( < bit number > of Destination) → Z; TEST ( < bit number > of Destination) → < bit number > of Destination				
25	BCHG	BCHG Dn,<ea>	0000.nnn.101.eee.aaa				x			2		x																			x			x	x	x	x	x	x	x	x			?	?	?	x	x																						TEST ( < bit number > of Destination) → Z; TEST ( < bit number > of Destination) → < bit number > of Destination				
26	BCHG	BCHG #<data8>,Dx	0000.100.001.000.xxx						x	2																			8		x	x																																						TEST ( < bit number > of Destination) → Z; TEST ( < bit number > of Destination) → < bit number > of Destination				
27	BCHG	BCHG #<data8>,<ea>	0000.100.001.eee.aaa				x			2																			8		x			x	x	x	x	x	x	x	x			?	?	?	x	x																						TEST ( < bit number > of Destination) → Z; TEST ( < bit number > of Destination) → < bit number > of Destination				
28	BCLR	BCLR Dn,Dx	0000.nnn.110.000.xxx						x	2		x																			x	x																																						TEST ( < bit number > of Destination) → Z; 0 → < bit number > of Destination				
29	BCLR	BCLR Dn,<ea>	0000.nnn.110.eee.aaa				x			2		x																			x			x	x	x	x	x	x	x	x			?	?	?	x	x																						TEST ( < bit number > of Destination) → Z; 0 → < bit number > of Destination				
30	BCLR	BCLR #<data8>,Dx	0000.100.010.000.xxx						x	2																			8		x	x																																						TEST ( < bit number > of Destination) → Z; 0 → < bit number > of Destination				
31	BCLR	BCLR #<data8>,<ea>	0000.100.010.eee.aaa				x			2																			8		x			x	x	x	x	x	x	x	x			?	?	?	x	x																						TEST ( < bit number > of Destination) → Z; 0 → < bit number > of Destination				
32	BFCHG	BFCHG <ea>{offset:width}	1110.101.011.eee.aaa	0000.o.fffff.w.iiiii		B				1	x	x		x			x	x	x	x	x						x	x																																										TEST ( < bit field > of Destination) → < bit field > of Destination				
33	BFCLR	BFCLR <ea>{offset:width}	1110.110.011.eee.aaa	0000.o.fffff.w.iiiii		B				1	x	x		x			x	x	x	x	x						x	x																																										0 → < bit field > of Destination				
34	BFEXTS	BFEXTS <ea>{offset:width},Dn	1110.101.111.eee.aaa	0.nnn.o.fffff.w.iiiii		B				2	x	x		x			x	x	x	x	x	x	x	x	x	x	x	x				x																																						< bit field > of Source → sign extended Dn				
35	BFEXTU	BFEXTU <ea>{offset:width},Dn	1110.100.111.eee.aaa	0.nnn.o.fffff.w.iiiii		B				2	x	x		x			x	x	x	x	x	x	x	x	x	x	x	x				x																																						< bit field > of Source → 0 filled Dn				
36	BFFFO	BFFFO <ea>{offset:width},Dn	1110.110.111.eee.aaa	0.nnn.o.fffff.w.iiiii		B				2	x	x		x			x	x	x	x	x	x	x	x	x	x	x	x				x																																						< bit offset > of Source Bit Scan → Dn				
37	BFINS	BFINS Dn,<ea>{offset:width}	1110.111.111.eee.aaa	0.nnn.o.fffff.w.iiiii		B				1		x																			x	x		x			x	x	x	x	x						x	x																						Dn → < bit field > of Destination				
38	BFSET	BFSET <ea>{offset:width}	1110.111.011.eee.aaa	0000.o.fffff.w.iiiii		B				1	x	x		x			x	x	x	x	x						x	x																																										1 → < bit field > of Destination				
39	BFTST	BFTST <ea>{offset:width}	1110.100.011.eee.aaa	0000.o.fffff.w.iiiii		B				1	x	x		x			x	x	x	x	x						x	x																																										< bit field > of Destination				
40	BKPT	BKPT #<data3>	0100.100.001.001.ddd							1																			3																																									Run Breakpoint Acknowledge Cycle; TRAP As Illegal Instruction				
41	BRA	BRA <data8>	0110.0000.dddddddd							1																				8!{0,-1}																																								PC + Displacement → PC				
42	BRA	BRA <data16>	0110.0000.00000000							1																				16																																								PC + Displacement → PC				
43	BRA	BRA <data32>	0110.0000.11111111							1																				32																																								PC + Displacement → PC	x			
44	BSET	BSET Dn,Dx	0000.nnn.111.000.xxx						x	2		x																			x	x																																						TEST ( < bit number > of Destination) → Z; 1 → < bit number > of Destination				
45	BSET	BSET Dn,<ea>	0000.nnn.111.eee.aaa				x			2		x																			x			x	x	x	x	x	x	x	x						x	x																						TEST ( < bit number > of Destination) → Z; 1 → < bit number > of Destination				
46	BSET	BSET #<data8>,Dx	0000.100.011.000.xxx						x	2																			8		x	x																																						TEST ( < bit number > of Destination) → Z; 1 → < bit number > of Destination				
47	BSET	BSET #<data8>,<ea>	0000.100.011.eee.aaa				x			2																			8		x			x	x	x	x	x	x	x	x						x	x																						TEST ( < bit number > of Destination) → Z; 1 → < bit number > of Destination				
48	BSR	BSR <data8>	0110.0001.dddddddd							1																				8!{0,-1}																																								SP – 4 → SP; PC → (SP); PC + dn → PC				
49	BSR	BSR <data16>	0110.0001.00000000							1																				16																																								SP – 4 → SP; PC → (SP); PC + dn → PC				
50	BSR	BSR <data32>	0110.0001.11111111							1																				32																																								SP – 4 → SP; PC → (SP); PC + dn → PC	x			
51	BTST	BTST Dn,Dx	0000.nnn.100.000.xxx						x	2		x																			x	x																																						TEST ( < bit number > of Destination) → Z				
52	BTST	BTST Dn,<ea>	0000.nnn.100.eee.aaa				x			2		x																			x			x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x																					TEST ( < bit number > of Destination) → Z				
53	BTST	BTST #<data8>,Dx	0000.100.000.000.xxx						x	2																			8		x	x																																						TEST ( < bit number > of Destination) → Z				
54	BTST	BTST #<data8>,<ea>	0000.100.000.eee.aaa				x			2																			8		x			x	x	x	x	x	x	x	x	x	x	x	x	x	x	x																						TEST ( < bit number > of Destination) → Z				
55	CALLM	CALLM #<data8>,<ea>	0000.011.011.eee.aaa							2																			8		x			x			x	x	x	x	x	x	x	x	x	x	x	x																						Save Current Module State on Stack; Load New Module State from Destination				
56	CAS	CAS Dc,Du,<ea>	0000.1ss.011.eee.aaa	0000.000.uuu.000.ccc		CAS	x	x	x	3		x																				x																			x			x	x	x	x	x	x	x	x						x	x		Destination Operand – Compare Operand → cc; If Z, Update Operand → Destination Operand Else Destination Operand → Compare Operand	x			
57	CAS2	CAS2 Dc1:Dc2,Du1:Du2,(Rn1):(Rn2)	0000.1ss.011.111.100	R.nnn.000.uuu.000.ccc	R.nnn.000.uuu.000.ccc	CAS	x	x	x	3		x:x																				x:x																					r:r																	Destination Operand 1 – Compare 1 → cc ; If Z, Destination Operand 2 – Compare 2 → cc ; If Z, Update 1 → Destination Operand 1; Update 2 → Destination Operand 2 ; Else Destination Operand 1 → Compare 1; Destination Operand 2 → Compare 2	x			
58	CHK	CHK <ea>,Dn	0100.nnn.ss0.eee.aaa					x		2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						If Dn < 0 or Dn > Source Then TRAP				
59	CHK	CHK <ea>,Dn	0100.nnn.ss0.eee.aaa						x	2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						If Dn < 0 or Dn > Source Then TRAP	x			
60	CHK2	CHK <ea>,Rn	0000.0ss.011.eee.aaa	R.nnn.100.000.000.000			x	x	x	2	x			x			x	x	x	x	x	x	x	x	x	x	x	x				x	x																																					If Rn < LB or Rn > UB Then TRAP	x			
61	CLR	CLR <ea>	0100.001.0ss.eee.aaa				x	x	x	1	x	x		x	x	x	x	x	x	x	x						x	x																																										0 → Destination				
62	CMP	CMP <ea>,Dn	1101.nnn.000.eee.aaa				x			2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						Destination – Source → cc				
63	CMP	CMP <ea>,Dn	1101.nnn.001.eee.aaa					x		2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						Destination – Source → cc				
64	CMP	CMP <ea>,Dn	1101.nnn.010.eee.aaa						x	2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x			x																																						Destination – Source → cc				
65	CMPA	CMPA <ea>,An	1011.nnn.011.eee.aaa					x		2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		x		x																																					Destination – Source → cc				
66	CMPA	CMPA <ea>,An	1011.nnn.111.eee.aaa						x	2	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		x		x																																					Destination – Source → cc				
67	CMPI	CMPI #<data>,<ea>	0000.110.0ss.eee.aaa				x	x	x	2																			x		x	x		x	x	x	x	x	x	x	x			x	x	x	x	x																						Destination – Immediate data → cc				
68	CMPI	CMPI #<data>,<ea>	0000.110.0ss.eee.aaa				x	x	x	2																			x		x											x	x																											Destination – Immediate data → cc			x	
69	CMPM	CMPM (Ay)+,(Ax)+	1011.xxx.1ss.001.yyy				x	x	x	2	x				x																				x																																			Destination – Source → cc				
70	CMP2	CMP2 <ea>,Rn	0000.0ss.011.eee.aaa	R.nnn.000.000.000.000			x	x	x	2	x			x			x	x	x	x	x	x	x	x	x	x	x	x			x	r	r																																					Compare Rn<LB or Rn>UB and Set Condition Codes	x			
71	cpBcc	cpBcc #<data>	1111.ppp.01s.ccc.ccc	opt. coproc. ext. words	1,2,more ?			x	x	1																				16:32																																								If cpcc True Then Scan PC + dn → PC	x			x
72	cpDBcc	cpDBcc Dn,#<data>	1111.ppp.001.001.nnn	0000.000.000.ccc.ccc	opt.coproc. ext. words			x		2	x	x																																						16																				If cpcc False Then (Dn – 1 → Dn; If Dn ≠ – 1 Then Scan PC + dn → PC)	x			x
73	cpGEN	cpGEN #<command>	1111.ppp.000.eee.aaa	coproc. command word	e.a. or coproc. ext. words					1	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?	?																																									Pass Command Word to Coprocessor	x			
74	cpScc	cpScc <ea>	1111.ppp.001.eee.aaa	0000.000.000.ccc.ccc	e.a. or coproc. ext. words					1	x	x		x	x	x	x	x	x	x	x						x	x																																										If cpcc True Then 1s → Destination Else 0s → Destination	x			
75	cpTRAPcc	cpTRAPcc	1111.ppp.001.111.100	0000.000.000.ccc.ccc	opt.coproc. ext. words					0																																																												If cpcc True Then TRAP	x			
76	cpTRAPcc	cpTRAPcc #<data16>	1111.ppp.001.111.010	0000.000.000.ccc.ccc	opt.coproc. ext. words					1																			16																																									If cpcc True Then TRAP	x			
77	cpTRAPcc	cpTRAPcc #<data32>	1111.ppp.001.111.011	0000.000.000.ccc.ccc	opt.coproc. ext. words					1																			32																																									If cpcc True Then TRAP	x			
78	DBcc	DBcc Dn,#<data16>	0101.cccc.11.001.nnn							2	x	x																																						16																				If Condition False Then (Dn – 1 → Dn; If Dn ≠ – 1 Then PC + dn → PC)				
79	DIVS	DIVS <ea>,Dn	1000.nnn.111.eee.aaa					x		2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		32		x																																						Destination(32) ÷ Source(32) → Destination(32) = remainder(16).quotient(16))				
80	DIVS	DIVS <ea>,Dq	0100.110.001.eee.aaa	0.qqq.100.000.000.qqq					x	2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		32		x																																						Destination(32 )÷ Source(32) → Destination(32) = quotient(32)	x			
81	DIVS	DIVS <ea>,Dr:Dq	0100.110.001.eee.aaa	0.qqq.110.000.000.rrr					x	2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		32		x:x																																						Destination(64:Dr.Dq) ÷ Source(32) → Destination(64) = remainder(32:Dr).quotient(32:Dq)	x			
82	DIVSL	DIVSL <ea>,Dr:Dq	0100.110.001.eee.aaa	0.qqq.100.000.000.rrr					x	2	x	x		x	x	x	x	x	x	x	x	x	x	x	x	x	x	x		32		x:x																																						Destination(32:Dq) ÷ Source(32) → Destination(64) = remainder(32:Dr).quotient(32:Dq)	x			